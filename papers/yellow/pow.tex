\section{Consensus}

\dnote{describe, why did we chosen Proof-of-Work rather than PoS/PoXXX}

Ergo PoW algorithm was designed with 2 goals in mind:

\begin{itemize}
    \item{\em ASIC resistance } - the concentration of mining power to ASIC-equipped miners
    is a big security issue.
    ASIC-resistant PoW algorithm should allow to generate new blocks with non-negligible
    probability on commodity hardware.
    Equihash algorithm was chosen as a promising ASIC-resistant PoW algorithm.
    \item{\em pools resistance } - even if mining hardware is distributed between multiply parties,
    their union into mining pools leads to centralization of the network control in hands of the mining pool operators.
    Ergo PoW algorithm should disincentivize large mining pools, ensuring that mining pools are small (if possible).
\end{itemize}

\subsection{Equihash}

In Equihash a miner should find a solution of the generalized paradox of birthdays - it should find
$2^k$ such words \term{n} bits length each, that xor for all this words should be 0.
Moreover hash of block header (including solutions) should be less than some predefined target.

Search for Equihash solutions works as follows:

\begin{algorithm}[H]
    \caption{Equihash mining}
    \label{alg:eq:mining}
    \begin{algorithmic}[1]
        \Function{solveEquihash}{$header$, $target$}
            \Let{$solutions$}{$findSolutions(header)$}
            \Let{$correctHeaders$}{$solutions.filter(s => hash(header.copy(solution = s)) < target)$}
            \If{$correctHeaders.nonEmpty$}

                \Return $correctHeaders$
            \Else
                \State Modify header by updating timestamp, transactions or other fields

                \Return $solveEquihash(modifiedHeader, target)$
            \EndIf
        \EndFunction

        \Function{findSolutions}{$header$}
            \Let{$seed$}{$hash(header.bytesWithoutPoW)$}
            \Let{$listSize$}{$2*2^{n / (k + 1)}$}
            \Let{$X$}{(0 to listSize).map(j => (hash(seed + j), j))}
            \For{r: 1 until k}
              \Let{$X$}(round(X, r))
            \EndFor
            \State find all possible collisions on the last $2n/k+1$ bits.

            \Return Sequence of solutions, where every solution is a sequence of indexes of words from X.
        \EndFunction

        \Function{round}{$X$, $r$}
        \State Sort the $X$ by values $X_j$ .
        \State Then find all unordered pairs $(i, j)$ such that $X_i$ collides with $X_j$ on the first $r * n/(k+1)$ bits.

        \Return $(X_{i,j} = X_i$ xor $X_j, (i , j))$
        \EndFunction

    \end{algorithmic}
\end{algorithm}

Equihash solutions consists of $2^k$ integer indexes.
Verification of Equihash solutions works as follows:
\begin{algorithm}[H]
    \caption{Equihash validation}
    \label{alg:eq:valudation}
    \begin{algorithmic}[1]
        \Function{validateEquihash}{$header$, $solution$}
        \State check, that there is no duplicate indexes in solutions
        \Let{$X$}{solution.map(j => (hash(seed + j), j))}
        \State check algorithm binding - words in $X$ have a special order and XOR for pairs at every step should start from required number of 0
        \State check, that XOR for all X consists of 0 bits only

        \Return hash(header) < target
        \EndFunction
    \end{algorithmic}
\end{algorithm}

\subsection{Pool resistance}

This section contains few proposals, how to prevent mining outsourcing:

\begin{itemize}
    \item{\em use private key } - ensure that private key was involved in mining process.
    Miner should include his public key and signature $Sig$ of all block fields to block header
    (or other parts of the block, like extension or block transactions)
    and all mining rewards goes to this public key.
    Equihash should use this signature as a $seed$ and also verifier should check, that indexes of solutions do
    not exceed $listSize$.
    To ensure, that mining reward goes to public key used in block signing, all anyone-can-spend outputs should
    be collected to that public key (or may be it's better to create special miner-can-spend opcode to ensure
    that nobody else can collect this output).
    Thus, for every search of Equihash solutions miner should sign a block.
    Pools might still be possible, but they should send a new signature for every Equihash operation that might
    be impossible for large pools. Current ZCash hashrate is $8*10^8$ Sol/s, thus pool, that controls 25\%
    of hashrate should calculate $2*10^8$ signatures every second and sent 10 Gb of data per second.

\end{itemize}
